defmodule Mix.Tasks.Compile.MyTask do
    use Mix.Task
    require Hok
    @recursive true
    @moduledoc "Runs a task after all other compilation."
  
    def run(_args) do
      IO.puts("Compiling Generated CUDA code for Hok application!!!")
      Hok.get_default_type()
      |> Enum.map(fn v -> compile_module(v) end)
      # Your custom execution logic here
      :ok
    end
    def compile_module({id,type}) do
      
      app = Hok.get_app()
 
      code = Hok.CudaBackend.compile_module(:app, app, type)
      module_name = "Elixir.app_#{to_string(id)}"
      # IO.puts "Module name: #{module_name}"
   
      file = File.open!("c_src/#{module_name}.cu", [:write])
      IO.write(file, "#include \"erl_nif.h\"\n\n" <> code)
      File.close(file)
      {result, errcode} = System.cmd("nvcc",
         [ "--shared",
           "--compiler-options",
           "'-fPIC'",
           "-o",
           "priv/#{module_name}.so",
           "c_src/#{module_name}.cu"
   ], stderr_to_stdout: true)
 
   if ((errcode == 1) || (errcode ==2)) do 
     raise "Error when compiling .cu file generated by Hok:\n#{result}" 
   end
   
   lib=Hok.load_lib_nif(to_charlist(module_name))
   Hok.add_lib_server(to_charlist(module_name),lib)
    
  

    end
  end